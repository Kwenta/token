{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "contracts-exposed/EscrowedMultipleMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../contracts/EscrowedMultipleMerkleDistributor.sol\";\n\ncontract $EscrowedMultipleMerkleDistributor is EscrowedMultipleMerkleDistributor {\n    constructor(address _owner, address _token, address _rewardEscrow) EscrowedMultipleMerkleDistributor(_owner, _token, _rewardEscrow) {}\n}\n"
    },
    "contracts-exposed/interfaces/IEscrowedMultipleMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/interfaces/IEscrowedMultipleMerkleDistributor.sol\";\n\nabstract contract $IEscrowedMultipleMerkleDistributor is IEscrowedMultipleMerkleDistributor {\n    constructor() {}\n}\n"
    },
    "contracts-exposed/interfaces/IRewardEscrowV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/interfaces/IRewardEscrowV2.sol\";\n\nabstract contract $IRewardEscrowV2 is IRewardEscrowV2 {\n    constructor() {}\n}\n"
    },
    "contracts-exposed/utils/Owned.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.6.0;\n\nimport \"../../contracts/utils/Owned.sol\";\n\ncontract $Owned is Owned {\n    constructor(address _owner) Owned(_owner) {}\n}\n"
    },
    "contracts/EscrowedMultipleMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./utils/Owned.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"./interfaces/IRewardEscrowV2.sol\";\nimport \"./interfaces/IEscrowedMultipleMerkleDistributor.sol\";\n\n/// @title Kwenta EscrowedMultipleMerkleDistributor\n/// @author JaredBorders and JChiaramonte7\n/// @notice Facilitates trading incentives distribution over multiple periods.\ncontract EscrowedMultipleMerkleDistributor is\n    IEscrowedMultipleMerkleDistributor,\n    Owned\n{\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    address public immutable override rewardEscrow;\n\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    address public immutable override token;\n\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    mapping(uint256 => bytes32) public override merkleRoots;\n\n    /// @notice an epoch to packed array of claimed booleans mapping\n    mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMaps;\n\n    /// @notice set addresses for deployed rewardEscrow and KWENTA.\n    /// Establish merkle root for verification\n    /// @param _owner: designated owner of this contract\n    /// @param _token: address of erc20 token to be distributed\n    /// @param _rewardEscrow: address of kwenta escrow for tokens claimed\n    constructor(\n        address _owner,\n        address _token,\n        address _rewardEscrow\n    ) Owned(_owner) {\n        token = _token;\n        rewardEscrow = _rewardEscrow;\n    }\n\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    function setMerkleRootForEpoch(\n        bytes32 merkleRoot,\n        uint256 epoch\n    ) external override onlyOwner {\n        merkleRoots[epoch] = merkleRoot;\n        emit MerkleRootModified(epoch);\n    }\n\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    function isClaimed(\n        uint256 index,\n        uint256 epoch\n    ) public view override returns (bool) {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        uint256 claimedWord = claimedBitMaps[epoch][claimedWordIndex];\n        uint256 mask = (1 << claimedBitIndex);\n        return claimedWord & mask == mask;\n    }\n\n    /// @notice set claimed status for indexed claim to true\n    /// @param index: used for claim managment\n    /// @param epoch: distribution index to check\n    function _setClaimed(uint256 index, uint256 epoch) private {\n        uint256 claimedWordIndex = index / 256;\n        uint256 claimedBitIndex = index % 256;\n        claimedBitMaps[epoch][claimedWordIndex] =\n            claimedBitMaps[epoch][claimedWordIndex] |\n            (1 << claimedBitIndex);\n    }\n\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    function claim(\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof,\n        uint256 epoch\n    ) public override {\n        require(\n            !isClaimed(index, epoch),\n            \"EscrowedMultipleMerkleDistributor: Drop already claimed.\"\n        );\n\n        // verify the merkle proof\n        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n        require(\n            MerkleProof.verify(merkleProof, merkleRoots[epoch], node),\n            \"EscrowedMultipleMerkleDistributor: Invalid proof.\"\n        );\n\n        // mark it claimed and send the token to RewardEscrow\n        _setClaimed(index, epoch);\n        IERC20(token).approve(rewardEscrow, amount);\n        IRewardEscrowV2(rewardEscrow).createEscrowEntry(\n            account,\n            amount,\n            IRewardEscrowV2(rewardEscrow).DEFAULT_DURATION(),\n            IRewardEscrowV2(rewardEscrow).DEFAULT_EARLY_VESTING_FEE()\n        );\n\n        emit Claimed(index, account, amount, epoch);\n    }\n\n    /// @inheritdoc IEscrowedMultipleMerkleDistributor\n    function claimMultiple(Claims[] calldata claims) external override {\n        uint256 cacheLength = claims.length;\n        for (uint256 i = 0; i < cacheLength; ) {\n            claim(\n                claims[i].index,\n                claims[i].account,\n                claims[i].amount,\n                claims[i].merkleProof,\n                claims[i].epoch\n            );\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IEscrowedMultipleMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\n// Allows anyone to claim a token if they exist in a merkle root.\ninterface IEscrowedMultipleMerkleDistributor {\n    /// @notice data structure for aggregating multiple claims\n    struct Claims {\n        uint256 index;\n        address account;\n        uint256 amount;\n        bytes32[] merkleProof;\n        uint256 epoch;\n    }\n\n    /// @notice event is triggered whenever a call to `claim` succeeds\n    event Claimed(\n        uint256 index,\n        address account,\n        uint256 amount,\n        uint256 epoch\n    );\n\n    /// @notice event is triggered whenever a merkle root is set\n    event MerkleRootModified(uint256 epoch);\n\n    /// @return escrow for tokens claimed\n    function rewardEscrow() external view returns (address);\n\n    /// @return token to be distributed (KWENTA)\n    function token() external view returns (address);\n\n    // @return the merkle root of the merkle tree containing account balances available to claim\n    function merkleRoots(uint256) external view returns (bytes32);\n\n    /// @notice determine if indexed claim has been claimed\n    /// @param index: used for claim managment\n    /// @param epoch: distribution index number\n    /// @return true if indexed claim has been claimed\n    function isClaimed(uint256 index, uint256 epoch)\n        external\n        view\n        returns (bool);\n\n    /// @notice attempt to claim as `account` and escrow KWENTA for `account`\n    /// @param index: used for merkle tree managment and verification\n    /// @param account: address used for escrow entry\n    /// @param amount: $KWENTA amount to be escrowed\n    /// @param merkleProof: off-chain generated proof of merkle tree inclusion\n    /// @param epoch: distribution index number\n    function claim(\n        uint256 index,\n        address account,\n        uint256 amount,\n        bytes32[] calldata merkleProof,\n        uint256 epoch\n    ) external;\n\n    /// @notice function that aggregates multiple claims\n    /// @param claims: array of valid claims\n    function claimMultiple(Claims[] calldata claims) external;\n\n    /// @notice modify merkle root for existing distribution epoch\n    /// @param merkleRoot: new merkle root\n    /// @param epoch: distribution index number\n    function setMerkleRootForEpoch(bytes32 merkleRoot, uint256 epoch) external;\n}\n"
    },
    "contracts/interfaces/IRewardEscrowV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IRewardEscrowV2 {\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice A vesting entry contains the data for each escrow NFT\n    struct VestingEntry {\n        // The amount of KWENTA stored in this vesting entry\n        uint256 escrowAmount;\n        // The length of time until the entry is fully matured\n        uint256 duration;\n        // The time at which the entry will be fully matured\n        uint256 endTime;\n        // The percentage fee for vesting immediately\n        // The actual penalty decreases linearly with time until it reaches 0 at block.timestamp=endTime\n        uint256 earlyVestingFee;\n    }\n\n    /// @notice The same as VestingEntry but packed to fit in a single slot\n    struct VestingEntryPacked {\n        uint144 escrowAmount;\n        uint40 duration;\n        uint64 endTime;\n        uint8 earlyVestingFee;\n    }\n\n    /// @notice Helper struct for getVestingSchedules view\n    struct VestingEntryWithID {\n        // The amount of KWENTA stored in this vesting entry\n        uint256 escrowAmount;\n        // The unique ID of this escrow entry NFT\n        uint256 entryID;\n        // The time at which the entry will be fully matured\n        uint256 endTime;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                                INITIALIZER\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract\n    /// @param _owner The address of the owner of this contract\n    /// @dev this function should be called via proxy, not via direct contract interaction\n    function initialize(address _owner) external;\n\n    /*///////////////////////////////////////////////////////////////\n                                SETTERS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Function used to define the StakingRewardsV2 contract address to use\n    /// @param _stakingRewards The address of the StakingRewardsV2 contract\n    /// @dev This function can only be called once\n    function setStakingRewards(address _stakingRewards) external;\n\n    /// @notice Function used to define the EscrowMigrator contract address to use\n    /// @param _escrowMigrator The address of the EscrowMigrator contract\n    function setEscrowMigrator(address _escrowMigrator) external;\n\n    /// @notice Function used to define the TreasuryDAO address to use\n    /// @param _treasuryDAO The address of the TreasuryDAO\n    /// @dev This function can only be called multiple times\n    function setTreasuryDAO(address _treasuryDAO) external;\n\n    /*///////////////////////////////////////////////////////////////\n                                VIEWS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Minimum early vesting fee\n    /// @dev this must be high enought to prevent governance attacks where the user\n    /// can set the early vesting fee to a very low number, stake, vote, then withdraw\n    /// via vesting which avoids the unstaking cooldown\n    function MINIMUM_EARLY_VESTING_FEE() external view returns (uint256);\n\n    /// @notice Default early vesting fee\n    /// @dev This is the default fee applied for early vesting\n    function DEFAULT_EARLY_VESTING_FEE() external view returns (uint256);\n\n    /// @notice Default escrow duration\n    /// @dev This is the default duration for escrow\n    function DEFAULT_DURATION() external view returns (uint256);\n\n    /// @notice helper function to return kwenta address\n    function getKwentaAddress() external view returns (address);\n\n    /// @notice A simple alias to totalEscrowedAccountBalance\n    function escrowedBalanceOf(address _account) external view returns (uint256);\n\n    /// @notice Get the amount of escrowed kwenta that is not staked for a given account\n    function unstakedEscrowedBalanceOf(address _account) external view returns (uint256);\n\n    /// @notice Get the details of a given vesting entry\n    /// @param _entryID The id of the vesting entry.\n    /// @return endTime the vesting entry object\n    /// @return escrowAmount rate per second emission.\n    /// @return duration the duration of the vesting entry.\n    /// @return earlyVestingFee the early vesting fee of the vesting entry.\n    function getVestingEntry(uint256 _entryID)\n        external\n        view\n        returns (uint256, uint256, uint256, uint256);\n\n    /// @notice Get the vesting entries for a given account\n    /// @param _account The account to get the vesting entries for\n    /// @param _index The index of the first vesting entry to get\n    /// @param _pageSize The number of vesting entries to get\n    /// @return vestingEntries the list of vesting entries with ids\n    function getVestingSchedules(address _account, uint256 _index, uint256 _pageSize)\n        external\n        view\n        returns (VestingEntryWithID[] memory);\n\n    /// @notice Get the vesting entries for a given account\n    /// @param _account The account to get the vesting entries for\n    /// @param _index The index of the first vesting entry to get\n    /// @param _pageSize The number of vesting entries to get\n    /// @return vestingEntries the list of vesting entry ids\n    function getAccountVestingEntryIDs(address _account, uint256 _index, uint256 _pageSize)\n        external\n        view\n        returns (uint256[] memory);\n\n    /// @notice Get the amount that can be vested now for a set of vesting entries\n    /// @param _entryIDs The ids of the vesting entries to get the quantity for\n    /// @return total The total amount that can be vested for these entries\n    /// @return totalFee The total amount of fees that will be paid for these vesting entries\n    function getVestingQuantity(uint256[] calldata _entryIDs)\n        external\n        view\n        returns (uint256, uint256);\n\n    /// @notice Get the amount that can be vested now for a given vesting entry\n    /// @param _entryID The id of the vesting entry to get the quantity for\n    /// @return quantity The total amount that can be vested for this entry\n    /// @return totalFee The total amount of fees that will be paid for this vesting entry\n    function getVestingEntryClaimable(uint256 _entryID) external view returns (uint256, uint256);\n\n    /*///////////////////////////////////////////////////////////////\n                            MUTATIVE FUNCTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice Vest escrowed amounts that are claimable - allows users to vest their vesting entries based on msg.sender\n    /// @param _entryIDs The ids of the vesting entries to vest\n    function vest(uint256[] calldata _entryIDs) external;\n\n    /// @notice Utilized by the escrow migrator contract to transfer V1 escrow\n    /// @param _account The account to import the escrow entry to\n    /// @param entryToImport The vesting entry to import\n    function importEscrowEntry(address _account, VestingEntry memory entryToImport) external;\n\n    /// @notice Create an escrow entry to lock KWENTA for a given duration in seconds\n    /// @param _beneficiary The account that will be able to withdraw the escrowed amount\n    /// @param _deposit The amount of KWENTA to escrow\n    /// @param _duration The duration in seconds to lock the KWENTA for\n    /// @param _earlyVestingFee The fee to apply if the escrowed amount is withdrawn before the end of the vesting period\n    /// @dev the early vesting fee decreases linearly over the vesting period\n    /// @dev This call expects that the depositor (msg.sender) has already approved the Reward escrow contract\n    /// to spend the the amount being escrowed.\n    function createEscrowEntry(\n        address _beneficiary,\n        uint256 _deposit,\n        uint256 _duration,\n        uint256 _earlyVestingFee\n    ) external;\n\n    /// @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n    /// @dev A call to this should accompany a previous successful call to kwenta.transfer(rewardEscrow, amount),\n    /// to ensure that when the funds are withdrawn, there is enough balance.\n    /// This is only callable by the staking rewards contract\n    /// The duration defaults to 1 year, and the early vesting fee to 90%\n    /// @param _account The account to append a new vesting entry to.\n    /// @param _quantity The quantity of KWENTA that will be escrowed.\n    function appendVestingEntry(address _account, uint256 _quantity) external;\n\n    /// @notice Transfer multiple entries from one account to another\n    ///  Sufficient escrowed KWENTA must be unstaked for the transfer to succeed\n    /// @param _from The account to transfer the entries from\n    /// @param _to The account to transfer the entries to\n    /// @param _entryIDs a list of the ids of the entries to transfer\n    function bulkTransferFrom(address _from, address _to, uint256[] calldata _entryIDs) external;\n\n    /// @dev Triggers stopped state\n    function pauseRewardEscrow() external;\n\n    /// @dev Returns to normal state.\n    function unpauseRewardEscrow() external;\n\n    /*///////////////////////////////////////////////////////////////\n                                EVENTS\n    ///////////////////////////////////////////////////////////////*/\n\n    /// @notice emitted when an escrow entry is vested\n    /// @param beneficiary The account that was vested to\n    /// @param value The amount of KWENTA that was vested\n    event Vested(address indexed beneficiary, uint256 value);\n\n    /// @notice emitted when an escrow entry is created\n    /// @param beneficiary The account that gets the entry\n    /// @param value The amount of KWENTA that was escrowed\n    /// @param duration The duration in seconds of the vesting entry\n    /// @param entryID The id of the vesting entry\n    /// @param earlyVestingFee The early vesting fee of the vesting entry\n    event VestingEntryCreated(\n        address indexed beneficiary,\n        uint256 value,\n        uint256 duration,\n        uint256 entryID,\n        uint256 earlyVestingFee\n    );\n\n    /// @notice emitted when the staking rewards contract is set\n    /// @param stakingRewards The address of the staking rewards contract\n    event StakingRewardsSet(address stakingRewards);\n\n    /// @notice emitted when the escrow migrator contract is set\n    /// @param escrowMigrator The address of the escrow migrator contract\n    event EscrowMigratorSet(address escrowMigrator);\n\n    /// @notice emitted when the treasury DAO is set\n    /// @param treasuryDAO The address of the treasury DAO\n    event TreasuryDAOSet(address treasuryDAO);\n\n    /// @notice emitted when the early vest fee is sent to the treasury and notifier\n    /// @param amountToTreasury The amount of KWENTA sent to the treasury\n    /// @param amountToNotifier The amount of KWENTA sent to the notifier\n    event EarlyVestFeeSent(uint256 amountToTreasury, uint256 amountToNotifier);\n\n    /*//////////////////////////////////////////////////////////////\n                                ERRORS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Thrown when attempting to bulk transfer from and to the same address\n    error CannotTransferToSelf();\n\n    /// @notice Insufficient unstaked escrow to facilitate transfer\n    /// @param escrowAmount the amount of escrow attempted to transfer\n    /// @param unstakedBalance the amount of unstaked escrow available\n    error InsufficientUnstakedBalance(uint256 escrowAmount, uint256 unstakedBalance);\n\n    /// @notice Attempted to set entry early vesting fee beyond 100%\n    error EarlyVestingFeeTooHigh();\n\n    /// @notice cannot mint entries with early vesting fee below the minimum\n    error EarlyVestingFeeTooLow();\n\n    /// @notice error someone other than staking rewards calls an onlyStakingRewards function\n    error OnlyStakingRewards();\n\n    /// @notice error someone other than escrow migrator calls an onlyEscrowMigrator function\n    error OnlyEscrowMigrator();\n\n    /// @notice staking rewards is only allowed to be set once\n    error StakingRewardsAlreadySet();\n\n    /// @notice cannot set this value to the zero address\n    error ZeroAddress();\n\n    /// @notice cannot mint entries with zero escrow\n    error ZeroAmount();\n\n    /// @notice Cannot escrow with 0 duration OR above max_duration\n    error InvalidDuration();\n}\n"
    },
    "contracts/utils/Owned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}